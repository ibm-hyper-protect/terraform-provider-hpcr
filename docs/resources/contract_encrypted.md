---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "hpcr_contract_encrypted Resource - hpcr"
subcategory: ""
description: |-
  Generates an encrypted and signed Hyper Protect contract for deployment to Hyper Protect instances. This is the final step in the contract creation workflow, producing user data ready for VM provisioning.
---

# hpcr_contract_encrypted (Resource)

Generates an encrypted and signed Hyper Protect contract for deployment to Hyper Protect instances. This resource is the final step in the contract creation workflow, taking a YAML contract specification and producing an signed and encrypted user data field ready for VM provisioning.

## Overview

The Hyper Protect contract defines what workload runs in your secure enclave and how it's configured. This resource:

1. Takes a YAML-serialized contract as input
2. Signs the contract with a private key (generated or provided)
3. Encrypts the contract with an Hyper Protect encryption certificate (default or provided)
4. Outputs encrypted Hyper Protect format user data for IBM Cloud VPC / On Prem instance deployment

## Contract Structure

An HPCR contract typically contains these sections:

- **workload**: Defines the containerized application (docker-compose or podman play)
- **env**: Environment variables, logging configuration, and runtime settings
- **AttestationPublicKey** (Optional): Public key to encrypt the attestation records

See the [contract-go documentation](https://ibm-hyper-protect.github.io/contract-go) for detailed contract schema information.

## Signing and Encryption

**Signing**: Contracts are signed to prove authenticity. You can provide your own private key via `privkey`, or let the resource generate a temporary key.

**Encryption**: Contracts are encrypted using Hyper Protect encryption certificates. By default, the latest HPVS certificate is used. Specify `cert` for version-specific encryption.

## Platform Support

The `platform` parameter specifies the target Hyper Protect platform:
- `hpvs` (default) - Hyper Protect Virtual Servers
- `hpcr-rhvs` - Hyper Protect Container Runtime
- `hpcc-peerpod` - Hyper Protect Confidential Containers (Peer Pods)

## Example Usage

```terraform
terraform {
  required_providers {
    hpcr = {
      source  = "ibm-hyper-protect/hpcr"
      version = ">= 1.2.0"
    }
  }
}

# Create TGZ archive from pods folder
resource "hpcr_tgz" "contract" {
  folder = "pods"
}

# Create base64 of attestation public key
resource "hpcr_text" "attestation_public_key" {
  text = file("./public.pem")
}

# Define contract in clear text
locals {
  contract = yamlencode({
    "env" : {
      "type" : "env",
      "logging" : {
        "logRouter" : {
          "hostname" : "5c2d6b69-c7f0-41bd-b69b-240695369d6e.ingress.us-south.logs.cloud.ibm.com",
          "iamApiKey" : "ab00e3c09p1d4ff7fff9f04c12183413"
        }
      }
    },
    "workload" : {
      "type" : "workload",
      "play" : {
        "archive" : hpcr_tgz.contract.rendered
      }
    },
    "attestationPublicKey": hpcr_text.attestation_public_key.rendered
  })
}

# Basic contract with auto-generated signing key
resource "hpcr_contract_encrypted" "contract" {
  contract = local.contract
}

output "contract_rendered" {
  value = hpcr_contract_encrypted.contract.rendered
}

output "contract_sha256_in" {
  value = hpcr_contract_encrypted.contract.sha256_in
}

output "contract_sha256_out" {
  value = hpcr_contract_encrypted.contract.sha256_out
}

# Contract with custom encryption certificate
resource "hpcr_contract_encrypted" "contract_cert" {
  contract = local.contract
  cert     = file("./cert/encrypt.crt")
}

output "contract_cert_rendered" {
  value = hpcr_contract_encrypted.contract_cert.rendered
}

# Contract with custom signing key
resource "hpcr_contract_encrypted" "contract_privkey" {
  contract = local.contract
  privkey  = file("./cert/private.pem")
}

output "contract_privkey_rendered" {
  value = hpcr_contract_encrypted.contract_privkey.rendered
}

# Platform-specific contract
resource "hpcr_contract_encrypted" "contract_platform" {
  contract = local.contract
  platform = "hpvs"
}

output "contract_platform_rendered" {
  value = hpcr_contract_encrypted.contract_platform.rendered
}
```

## Best Practices

- Use separate `hpcr_text_encrypted` resources for workload and env sections when they contain sensitive data
- Store signing keys securely (e.g., HashiCorp Vault)
- Match encryption certificate version with your Hyper Protect image version
- Track contract checksums (`sha256_in`, `sha256_out`) for audit trails
- Test contracts in development environments before production deployment



<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `contract` (String, Sensitive) YAML serialization of the contract

### Optional

- `cert` (String) Certificate used to encrypt the contract, in PEM format. Defaults to the latest HPVS image certificate if not specified.
- `platform` (String) Hyper Protect platform where this contract will be deployed. Defaults to hpvs
- `privkey` (String, Sensitive) Private key used to sign the contract. If omitted, a temporary signing key is created.

### Read-Only

- `id` (String) Resource identifier
- `rendered` (String) Rendered output of the resource
- `sha256_in` (String) SHA256 of the input
- `sha256_out` (String) SHA256 of the output
